<HTML>
<HEAD>
<BASE TARGET="_top">
<TITLE>United States Patent: 7394377</TITLE></HEAD>
<BODY BGCOLOR="#FFFFFF">
<a name="top"></a>
<center>
<IMG SRC="/netaicon/PTO/patfthdr.gif" alt="[US Patent & Trademark Office, Patent Full Text and Image Database]">
<br>
<table>
<tr><td align=center>
<a href="http://www.uspto.gov/patft/index.html"><img src="/netaicon/PTO/home.gif" alt="[Home]" border="0" valign=middle></a>
<a href="/netahtml/PTO/search-bool.html"><img src="/netaicon/PTO/boolean.gif" alt="[Boolean Search]" border="0" valign=middle></a>
<A HREF="/netahtml/PTO/search-adv.htm"><IMG BORDER="0" SRC="/netaicon/PTO/manual.gif" ALT="[Manual Search]" valign=middle></A>
<a href="/netahtml/PTO/srchnum.htm"><img src="/netaicon/PTO/number.gif" alt="[Number Search]" border="0" valign=middle></a>
<A HREF="http://www.uspto.gov/patft/help/help.htm"><IMG BORDER="0" valign=middle SRC="/netaicon/PTO/help.gif" ALT="[Help]"></A>
</td></tr>
<tr><td align=center>
<A  HREF=/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=140&f=S&l=50&d=PTXT&s1=((RFID+OR+%22radio+frequency+identification%22).ABTX.+AND+(((Cryptography+OR+Crypto)+OR+Encryption)+OR+Cipher))&p=2&Query=abst/(RFID+or+(&quot;radio+frequency+identification&quot;))+AND+(Cryptography+or+Crypto+or+Encryption+or+Cipher)><IMG VALIGN=MIDDLE SRC=/netaicon/PTO/prevlist.gif border=0 ALT=[PREV_LIST]></A>
<A  HREF=/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=140&f=S&l=50&d=PTXT&s1=((RFID+OR+%22radio+frequency+identification%22).ABTX.+AND+(((Cryptography+OR+Crypto)+OR+Encryption)+OR+Cipher))&p=3&Query=abst/(RFID+or+(&quot;radio+frequency+identification&quot;))+AND+(Cryptography+or+Crypto+or+Encryption+or+Cipher)><IMG VALIGN=MIDDLE SRC=/netaicon/PTO/hitlist.gif border=0 ALT=[HIT_LIST]></A>
<A  HREF=/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=140&f=S&l=50&d=PTXT&s1=((RFID+OR+%22radio+frequency+identification%22).ABTX.+AND+(((Cryptography+OR+Crypto)+OR+Encryption)+OR+Cipher))&p=4&Query=abst/(RFID+or+(&quot;radio+frequency+identification&quot;))+AND+(Cryptography+or+Crypto+or+Encryption+or+Cipher)><IMG VALIGN=MIDDLE SRC=/netaicon/PTO/nextlist.gif border=0 ALT=[NEXT_LIST]></A>
<A  HREF=/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=139&f=G&l=50&d=PTXT&s1=((RFID+OR+%22radio+frequency+identification%22).ABTX.+AND+(((Cryptography+OR+Crypto)+OR+Encryption)+OR+Cipher))&p=3&OS=abst/(RFID+or+(&quot;radio+frequency+identification&quot;))+AND+(Cryptography+or+Crypto+or+Encryption+or+Cipher)><IMG VALIGN=MIDDLE SRC=/netaicon/PTO/prevdoc.gif border=0 ALT=[PREV_DOC]></A>
<A  HREF=/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=141&f=G&l=50&d=PTXT&s1=((RFID+OR+%22radio+frequency+identification%22).ABTX.+AND+(((Cryptography+OR+Crypto)+OR+Encryption)+OR+Cipher))&p=3&OS=abst/(RFID+or+(&quot;radio+frequency+identification&quot;))+AND+(Cryptography+or+Crypto+or+Encryption+or+Cipher)><IMG VALIGN=MIDDLE SRC=/netaicon/PTO/nextdoc.gif border=0 ALT=[NEXT_DOC]></A>

<a href="#bottom"><img src="/netaicon/PTO/bottom.gif" alt="[Bottom]" valign=middle border=0></A>
</td></tr>
<tr><td align=center>
<A HREF="http://ebiz1.uspto.gov/vision-service/ShoppingCart_P/ShowShoppingCart?backUrl1=http%3A//patft1.uspto.gov/netacgi/nph-Parser?Sect1%3DPTO2%26Sect2%3DHITOFF%26u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.htm%26r%3D140%26f%3DG%26l%3D50%26d%3DPTXT%26s1%3D((RFID%252BOR%252B%252522radio%252Bfrequency%252Bidentification%252522).ABTX.%252BAND%252B(((Cryptography%252BOR%252BCrypto)%252BOR%252BEncryption)%252BOR%252BCipher))%26p%3D3%26OS%3Dabst%2F(RFID%252Bor%252B(%252522radio%252Bfrequency%252Bidentification%252522))%252BAND%252B(Cryptography%252Bor%252BCrypto%252Bor%252BEncryption%252Bor%252BCipher)&backLabel1=Back%20to%20Document%3A%207394377"><img border=0 src="/netaicon/PTO/cart.gif" border=0 valign=middle alt="
[View Shopping Cart]"></A>
<A HREF="http://ebiz1.uspto.gov/vision-service/ShoppingCart_P/AddToShoppingCart?docNumber=7394377&backUrl1=http%3A//patft1.uspto.gov/netacgi/nph-Parser?Sect1%3DPTO2%26Sect2%3DHITOFF%26u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.htm%26r%3D140%26f%3DG%26l%3D50%26d%3DPTXT%26s1%3D((RFID%252BOR%252B%252522radio%252Bfrequency%252Bidentification%252522).ABTX.%252BAND%252B(((Cryptography%252BOR%252BCrypto)%252BOR%252BEncryption)%252BOR%252BCipher))%26p%3D3%26OS%3Dabst%2F(RFID%252Bor%252B(%252522radio%252Bfrequency%252Bidentification%252522))%252BAND%252B(Cryptography%252Bor%252BCrypto%252Bor%252BEncryption%252Bor%252BCipher)&backLabel1=Back%20to%20Document%3A%207394377">
<img border=0 src="/netaicon/PTO/order.gif" valign=middle alt="[Add to Shopping Cart]"></A>
</td></tr>
<tr><td align=center>
<a href=http://patimg2.uspto.gov/.piw?Docid=07394377&homeurl=http%3A%2F%2Fpatft.uspto.gov%2Fnetacgi%2Fnph-Parser%3FSect1%3DPTO2%2526Sect2%3DHITOFF%2526u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.htm%2526r%3D140%2526f%3DG%2526l%3D50%2526d%3DPTXT%2526s1%3D((RFID%252BOR%252B%252522radio%252Bfrequency%252Bidentification%252522).ABTX.%252BAND%252B(((Cryptography%252BOR%252BCrypto)%252BOR%252BEncryption)%252BOR%252BCipher))%2526p%3D3%2526OS%3Dabst%2F(RFID%252Bor%252B(%252522radio%252Bfrequency%252Bidentification%252522))%252BAND%252B(Cryptography%252Bor%252BCrypto%252Bor%252BEncryption%252Bor%252BCipher)%2526RS%3D(ABST%2F(RFID%252BOR%252B%252522radio%252Bfrequency%252Bidentification%252522)%252BAND%252B(((Cryptography%252BOR%252BCrypto)%252BOR%252BEncryption)%252BOR%252BCipher))&PageNum=&Rtype=&SectionNum=&idkey=NONE&Input=View+first+page><img src="/netaicon/PTO/image.gif" alt="[Image]" border="0" valign="middle"></A>

</td></tr>
</table>
</center>
<TABLE WIDTH="100%">
<TR><TD ALIGN="LEFT" width="50%">&nbsp;</TD>
<TD ALIGN=RIGHT VALIGN=BOTTOM WIDTH=50%><FONT SIZE=-1>( <STRONG>140</STRONG></FONT> <FONT SIZE=-2>of</FONT> <STRONG><FONT SIZE=-1>275</STRONG> )</FONT></TD></TR></TABLE>
<HR>
<TABLE WIDTH="100%">
<TR>	<TD ALIGN="LEFT" WIDTH="50%"><B>United States Patent </B></TD>
	<TD ALIGN="RIGHT" WIDTH="50%"><B>7,394,377</B></TD>
</TR>
<TR><TD ALIGN="LEFT" WIDTH="50%"><b>
 Banerjee
 </B>
</TD>
<TD ALIGN="RIGHT" WIDTH="50%"> <B>
July 1, 2008
</B></TD>
</TR>
</TABLE>
<HR>
<font size="+1">RFID edge server with security plug-ins
</font><BR>
<BR><CENTER><B>Abstract</B></CENTER>
<P>An <B><I>RFID</I></B> edge server using an application server allows for improvements in
     an <B><I>RFID</I></B> system.
</P>
<HR>
<TABLE WIDTH="100%"> <TR><TD VALIGN="TOP" ALIGN="LEFT" WIDTH="10%">Inventors: </TD><TD ALIGN="LEFT" WIDTH="90%">
 <B>Banerjee; Ashok</B> (Fremont, CA) </TD></TR><TR> <TD VALIGN="TOP" ALIGN="LEFT" WIDTH="10%">Assignee:</TD>
<TD ALIGN="LEFT" WIDTH="90%">

<B>BEA Systems, Inc.</B>
 (San Jose, 
CA)
<BR>

</TD>
</TR><TR><TD VALIGN="TOP" ALIGN="LEFT" WIDTH="10%" NOWRAP>Appl. No.:
</TD><TD ALIGN="LEFT" WIDTH="90%">                    
<B>11/256,767</B></TD></TR>
  <TR><TD VALIGN="TOP" ALIGN="LEFT" WIDTH="10%">Filed:
  </TD><TD ALIGN="LEFT" WIDTH="90%">                    
  <B>October 24, 2005</B></TD></TR>
</TABLE>
<HR> <CENTER><B>Related U.S. Patent Documents</B></CENTER> <HR> <TABLE WIDTH="100%"> <TR><TD WIDTH="7%"></TD><TD></TD><TD></TD><TD></TD><TD></TD><TD></TD></TR> <TR><TD align="left">
</TD><TD align=center><B><U>Application Number</U></B></TD><TD align=center><B><U>Filing Date</U></B></TD><TD align=center><B><U>Patent Number</U></B></TD><TD align=center><B><U>Issue Date</U></B></TD><TD</TD></TR><TR><TD align=center> </TD><TD align=center>60721023</TD><TD align=center>Sep., 2005</TD><TD align=center></TD><TD align=center></TD><TD</TD></TR><TR><TD align=center> </TD><TD align=center>60710243</TD><TD align=center>Aug., 2005</TD><TD align=center></TD><TD align=center></TD><TD</TD></TR><TR><TD align=center> 
</TD>
</TR> </TABLE><HR>
<p>
<TABLE WIDTH="100%">
  <TR><TD VALIGN=TOP ALIGN="LEFT" WIDTH="40%"><B>Current U.S. Class:</B></TD>
  <TD VALIGN=TOP ALIGN="RIGHT" WIDTH="80%"><B>340/572.1</B>  ; 340/10.1; 340/10.3; 717/176</TD></TR>
  <TR><TD VALIGN=TOP ALIGN="LEFT" WIDTH="40%"><B>Current International Class: </B></TD>
  <TD VALIGN=TOP ALIGN="RIGHT" WIDTH="80%">G08B 13/14&nbsp(20060101)</TD></TR>
  <TR><TD VALIGN=TOP ALIGN="LEFT" WIDTH="40%"><B>Field of Search: </B></TD>
  <TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="80%">
  










 340/10.1,572.1,572.7,10.3 717/176,120 235/375 709/220 370/428 705/30,9
  </TD></TR>
</TABLE>
<HR><CENTER><B>References Cited  <a href="/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2Fsearch-adv.htm&r=0&f=S&l=50&d=PALL&Query=ref/7394377">[Referenced By]</A></B></CENTER><HR>
<CENTER><b>U.S. Patent Documents</b></CENTER>
<TABLE WIDTH="100%"> <TR><TD WIDTH="33%"></TD><TD WIDTH="33%"></TD><TD WIDTH="34%"></TD></TR> <TR> <TD ALIGN="left">
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F6317028">6317028</a></TD><TD align =left>
November 2001</TD><TD align=left>
Valiulis</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F6854069">6854069</a></TD><TD align =left>
February 2005</TD><TD align=left>
Kampe et al.</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F6874020">6874020</a></TD><TD align =left>
March 2005</TD><TD align=left>
Da Palma et al.</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F7051105">7051105</a></TD><TD align =left>
May 2006</TD><TD align=left>
Lauzon et al.</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F7062540">7062540</a></TD><TD align =left>
June 2006</TD><TD align=left>
Reddy et al.</TD></TR><TR><TD align=left>
<a href="/netacgi/nph-Parser?Sect2=PTO1&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-bool.html&r=1&f=G&l=50&d=PALL&RefSrch=yes&Query=PN%2F7317394">7317394</a></TD><TD align =left>
January 2008</TD><TD align=left>
Koh et al.</TD></TR><TR><TD align=left>
<a href="http://appft1.uspto.gov/netacgi/nph-Parser?TERM1=20030043042&Sect1=PTO1&Sect2=HITOFF&d=PG01&p=1&u=%2Fnetahtml%2FPTO%2Fsrchnum.html&r=0&f=S&l=50" target="_blank">2003/0043042</a></TD><TD align =left>
March 2003</TD><TD align=left>
Moores, Jr. et al.</TD></TR><TR><TD align=left>
<a href="http://appft1.uspto.gov/netacgi/nph-Parser?TERM1=20030144926&Sect1=PTO1&Sect2=HITOFF&d=PG01&p=1&u=%2Fnetahtml%2FPTO%2Fsrchnum.html&r=0&f=S&l=50" target="_blank">2003/0144926</a></TD><TD align =left>
July 2003</TD><TD align=left>
Bodin et al.</TD></TR><TR><TD align=left>
<a href="http://appft1.uspto.gov/netacgi/nph-Parser?TERM1=20040087273&Sect1=PTO1&Sect2=HITOFF&d=PG01&p=1&u=%2Fnetahtml%2FPTO%2Fsrchnum.html&r=0&f=S&l=50" target="_blank">2004/0087273</a></TD><TD align =left>
May 2004</TD><TD align=left>
Perttila et al.</TD></TR><TR><TD align=left>
<a href="http://appft1.uspto.gov/netacgi/nph-Parser?TERM1=20040138989&Sect1=PTO1&Sect2=HITOFF&d=PG01&p=1&u=%2Fnetahtml%2FPTO%2Fsrchnum.html&r=0&f=S&l=50" target="_blank">2004/0138989</a></TD><TD align =left>
July 2004</TD><TD align=left>
O'Malley et al.</TD></TR><TR><TD align=left>
<a href="http://appft1.uspto.gov/netacgi/nph-Parser?TERM1=20060209868&Sect1=PTO1&Sect2=HITOFF&d=PG01&p=1&u=%2Fnetahtml%2FPTO%2Fsrchnum.html&r=0&f=S&l=50" target="_blank">2006/0209868</a></TD><TD align =left>
September 2006</TD><TD align=left>
Callaghan</TD></TR><TR><TD align=left>
<a href="http://appft1.uspto.gov/netacgi/nph-Parser?TERM1=20070027966&Sect1=PTO1&Sect2=HITOFF&d=PG01&p=1&u=%2Fnetahtml%2FPTO%2Fsrchnum.html&r=0&f=S&l=50" target="_blank">2007/0027966</a></TD><TD align =left>
February 2007</TD><TD align=left>
Singhal et al.</TD></TR><TR><TD align=left>

</TD>
</TR> </TABLE> <TABLE WIDTH="90%"> <BR> <CENTER><B>Other References</B></CENTER> <TR><TD><ALIGN=LEFT><BR>International Search Report for PCT/US06/02640, dated Dec. 9, 2007, 10 pages. cited by other. </TD></TR></TABLE> <BR>  <I>Primary Examiner:</I> La; Anh V
<BR>
  <I>Attorney, Agent or Firm:</I> <coma>Fliesler Meyer LLP
<BR>
<HR>
<CENTER><B><I>Parent Case Text</B></I></CENTER>
<HR>
<BR><BR>CLAIM OF PRIORITY
<BR><BR>This application claims priority to U.S. Provisional Application No.
     60/710,243 entitled "RFID Edge Server" by Ashok Banerjee, filed Aug. 22,
     2005 and U.S. Provisional Application No. 60/721,023 entitled "RFID Edge
     Server with Security Plug-Ins and WSRM" by Ashok Banerjee, filed Sep. 27,
     2005.
<HR>
<CENTER><B><I>Claims</B></I></CENTER> <HR> <BR><BR>What is claimed is:<BR><BR> 1.  A Radio Frequency Identification (RFID) edge server to associate with multiple RFID readers at a location, the RFID edge server including an application server using a
security framework, the security framework allowing for the use of a plug-in security module, wherein the security framework is such that the security framework uses an Application Programming Interface (API) that allows for the use of a default plug-in
security module and a third party plug-in security module, the third party plug-in security module having a different design from the default plug-in security module, wherein the plug-in security module for the application server of the RFID edge server
prevents the RFID edge server from being tampered with by unauthorized user.
<BR><BR> 2.  The RFID edge server of claim 1, wherein the RFID edge server is adapted to filter communications from the RFID readers.
<BR><BR> 3.  The RFID edge server of claim 1, wherein the RFID edge server and at least some of the RFID readers are interconnected using a local network.
<BR><BR> 4.  The RFID edge server of claim 1, wherein security framework ensures auditing.
<BR><BR> 5.  A computer readable storage medium includes code to implement an application server using a security framework for an RFID edge server, the security framework allowing for the use of a plug-in security module, wherein the security framework
is such that the security framework uses an API that allows for the use of a default plug-in security module and a third party plug-in security module, the third party plug-in security module having a different design from the default plug-in security
module, wherein the plug-in security module for the application server of the RFID edge server prevents the RFID edge server from being tampered with by unauthorized user.
<BR><BR> 6.  A computer readable storage medium of claim 5, wherein the security plug-in prevents the RFID edge server application from being tampered with by unauthorized users.
<BR><BR> 7.  A computer readable storage medium of claim 5, wherein the RFID edge server is adapted to filter communications from the RFID readers.
<BR><BR> 8.  A computer readable storage medium of claim 5, wherein the RFID edge server and at least some of the RFID readers are interconnected using a local network.
<BR><BR> 9.  A computer readable storage medium of claim 5, wherein security framework ensures auditing.<HR> <CENTER><B><I> Description</B></I></CENTER> <HR> <BR><BR>BACKGROUND OF INVENTION
<BR><BR>The present invention relates to Radio Frequency Identification (RFID) technology.  Radio Frequency Identification technology is becoming more and more important, especially to manage supply chains.
<BR><BR>Radio Frequency Identification technology can allow for the tracking of objects using RFID tags and RFID readers.  RFID readers can interrogate the RFID tags using radio waves.  The RFID tag typically includes an antenna and a microchip that
stores a response code.  The majority of RFID tags use a silicon microchip to store a unique serial number, such as an electronic product code (EPC), and usually some additional information.  The reader can pass the response code to a computer system to
track the objects.
<BR><BR>There are two main categories of RFID systems, passive and active systems.  Passive RFID tags do not have a transmitter but simply reflect back energy to the reader.  Active tags have their own transmitter and power source, such as a battery. 
Active RFID systems are typically used for a tracking large items since the active RFID tags are relatively expensive.
<BR><BR>Because passive RFID tags do not use a power source and transmitter, they tend to be cheaper than the active RFID tags.  Retailers and manufacturers are adding the passive tags to items in the supply chain.  RFID systems can significantly reduce
the cost of managing inventory.
<BR><BR>Passive RFID tags allow for the possibility of tracking of cartons of materials as they enter and exit entry points of a warehouses and stores.  As the passive RFID tags become cheaper, ultimately individual packages can have their own RFID tags
and thus the inventory can be tracked very precisely.  Additionally, since the RFID technology does not rely on line-of-sight operation, a shopping cart full of goods with RFID tags can be scanned without requiring the goods to be removed from the cart.
<BR><BR>In one embodiment, RFID tags can be used to implement an electronic product code (EPC).  The EPC is a unique number used to identify specific objects in the supply chain.  EPC information services (EPCIS) can enable users to exchange EPC related
data with trading partners throughout the EPC network. <BR><BR>BRIEF DESCRIPTION OF THE DRAWINGS
<BR><BR>FIG. 1 is a diagram of an RFID system of one embodiment.
<BR><BR>FIG. 2 is a diagram of an RFID edge server using non blocking IO for reading RFID reader data.
<BR><BR>FIG. 3 is a diagram illustrating the use of message filtering and event boxcarring at the RFID edge server.
<BR><BR>FIG. 4 is a diagram that illustrates the use of an archive to store and create a deployable unit of the RFID edge server itself to be deployed as an application and allow it to be quickly deployed into a standard web server.
<BR><BR>FIG. 5 is a diagram that illustrates an EPCIS server application archive, which allows the EPCIS server application to be deployed in a standards compliant way quickly into a standard J2EE Application Server.
<BR><BR>FIG. 6 is a diagram that illustrates the store and forward of messages from the RFID edge server to a notification recipient.
<BR><BR>FIG. 7 is a diagram that illustrates JMX administration at a RFID edge server.
<BR><BR>FIG. 8 is a diagram that illustrates the use of in-process Java connector to connect the RFID edge server to legacy/3.sup.rd party software.
<BR><BR>FIG. 9 is a diagram that illustrates an exemplary system of one embodiment.
<BR><BR>FIG. 10 is a diagram that illustrates an ALE processing engine.
<BR><BR>FIG. 11 is a diagram that illustrates the EPC commissioning process.
<BR><BR>FIG. 12 is a diagram that illustrates reader connectivity.
<BR><BR>FIG. 13 is a diagram that illustrates an RFID edge server with security plug-ins.
<BR><BR>FIG. 14 is a diagram that illustrates an RFID edge server with WSRM.
<BR><BR>DETAILED DESCRIPTION
<BR><BR>FIG. 1 illustrates a RFID system 100.  RFID readers 102 and 104 can be used to interrogate RFID tags 106, 108 and 110.  Data from the RFID tags, such as EPC codes, can be read by the RFID reader and provided to an RFID edge server 112. 
Typically, the RFID readers 102 and 104 are constantly interrogating for responses from the RFID tags 106, 108 and 110.  The RFID edge server 112 can thus receive a large number of duplicative responses.  RFID edge server 112 can send event reports to
the central server 114.  The central server 114 can include a EPCIS server 116 and enterprise application integration software 120.
<BR><BR>The RFID edge server can be used to provide RFID reader management, filtering, commissioning, and connectivity.  As disclosed below, in one embodiment the RFID edge server 102 can include application server, such as a J2EE application server. 
J2EE applications servers can run J2EE applications.  J2EE applications can be made up of components.  A J2EE component can be a self-contained functional software unit that is assembled into a J2EE application with its related classes and files and that
communicates with other components.  The J2EE specification defines the following J2EE components: Application clients and applets are components that run on the client.  Java Servlet and JavaServer Pages.TM.  (JSP.TM.) technology components are web
components that run on the server.  Enterprise JavaBeans.TM.  (EJB.TM.) components (enterprise beans) are business components that run on the server.
<BR><BR>J2EE components can be written in the Java programming language and can be compiled in the same way as any program in the language.  In one embodiment, The difference between J2EE components and "standard" Java classes is that J2EE components are
assembled into a J2EE application, are verified to be well formed and in compliance with the J2EE specification, and are deployed to production, where they are run and managed by the J2EE server.
<BR><BR>In one embodiment, the application server is the WebLogic Server.TM.  available from BEA Systems, Inc., of San Jose, Calif.
<BR><BR>The application server can run a RFID edge server infrastructure itself as a J2EE application.  RFID edge server application can include J2EE components and be packaged in an archive file such as a (Java Archive) JAR file or a Web Archive (WAR)
file.
<BR><BR>The use of an application server at the RFID edge server can provide a number of advantages.  The application server components can include: Java Messaging Server (JMS) to provide guaranteed message delivery and once message processing.  Security
to prevent unauthorized access.  The security module can be able to plug into 3.sup.rd party software and can utilize the secured socket layer (SSL) protocol.  Administration to manage the RFID edge server.  Administration can include JMX administration
and can be able to aggregate views and configure the RFID edge server.  Web services to receive and respond to web service requests.
<BR><BR>The RFID edge server can provide for RFID data filtering and business rules.  The RFID edge server can work with a variety of RFID readers.  Applications can interact with an RFID edge server through an Application-Level Events (ALE) interface. 
ALE can provide a way for developers to define high-level events that are needed by specific customer enterprise applications.  Enterprise applications receive incoming data in formats designed for easy integration and can obtain RFID data without
requiring programmers to interact directly with RFID readers or to perform any low-level real-time processing or scheduling.
<BR><BR>FIG. 10 illustrates an ALE processing engine that can be run at an application server at an RFID edge server.  FIG. 10 also shows common ALE filters.
<BR><BR>Application-Level Events (ALE) defines an interface through which an application could indicate exactly what information it wants from the raw stream of RFID reads.  Through ALE, an application can specify a number of things: Which locations it
wants to read from What interval of time to accumulate data How to filter the data How to group the results Whether to report currently visible tags or just additions or deletions Whether to report actual EPCs or just a count of the tags that are read.
<BR><BR>A request of this kind may be made in an on-demand mode, where the reads are performed in response to an application request, or as a standing request, where data is sent to the application periodically without further request.
<BR><BR>An RFID application can make a high-level request for data through the ALE interface, and the hardware or software on the other side of the ALE interface fulfills the request.  ALE shields applications from low-level implementation detail.
<BR><BR>Another benefit for end users is that ALE facilitates sharing RFID data among many applications simultaneously.  Different applications may make requests through the ALE interface, without requiring those applications to have knowledge of each
other.  If two applications request data from the same reader, the implementation of ALE mediates those requests and makes sure that each application receives the data it needs.  Using ALE each RFID can interact with a number of applications rather than
be just a dedicated peripheral for a specific application.
<BR><BR>The EPC Information Service (EPCIS) is a specification for a standard interface for accessing EPC-related information.  Because an Electronic Product Code (EPC) gives each object a unique serial number, each individual object can be tracked
independently and fine-grained real-time information about each individual object can be collected, stored and acted upon.  EPC Information Services are a way for supply chain partners to share and exchange information efficiently, because a standard
interface allows trading partners to use the same functions or methods for querying data across the supply chain, leading to reduced times integrating with partners if everyone uses the same interface, even though they may store the information in
different types of underlying databases.
<BR><BR>EPC Information Service is a technical specification for a data communication interface.  EPC Information Services are designed to support both on-demand polling access and a `push` model supporting standing queries.  Depending on how the
security for each individual EPCIS implementation is configured, you might be granted the right to define your own standing queries--or you might only have the option of `subscribing` to an existing query which was pre-defined by the owner or provider of
a particular EPCIS service.
<BR><BR>EPC-Related Data can Include:
<BR><BR> 1.  timestamped event data collected throughout the lifecycle of an object e.g. Observations (low-level tag readings), Measurements (sensor data, e.g. temperature history), Containment History, Higher-level Location History, Associations with
Business Transactions.  2.  quasi-static attributed data defined at serial-level but not continuously updated e.g. Date of Manufacture, Date of Expiry, Custom Configuration etc.
<BR><BR>The EPC Information Service lies at the top layer of the EPC Network technology stack.  EPCIS can allow business logic to be mixed with read `events` coming from RFID readers.  The layers underneath EPCIS (e.g. Filtering & Collection [ALE],
Reader Protocol etc.) can be primarily concerned with simple triples of data (Reader, Tag EPC, timestamp).  EPCIS allows for higher-level meanings to be stored or accessed, involving business processes and business transactions.
<BR><BR>The EPC Information Service Specification can specify the standard interfaces for: Query (getting data from an EPCIS) Capture (putting data into an EPCIS)
<BR><BR>The EPCIS interface can be implemented as an EPCIS server.  In terms of implementing an EPC Information Service, you can choose to either host your own EPCIS interface coupled to your existing databases for serial level data or subscribe to a
technology solution provider hosting a managed EPCIS service.
<BR><BR>Trading partners may be able to find an EPCIS by using the Object Name Service (ONS), doing a lookup based on the EPC of your products.  Serial-level pointers can also be stored securely within registries called Discovery Services.  Discovery
Service registries can be updated by each custodian on handover, with serial-level EPC lookup.
<BR><BR>FIG. 11 shows an example of EPCIS commissioning as a J2EE application that can run on an application server at an application server at an EPCIS server.  Alternately, some of the EPCIS functions can be run at an application server at an RFID edge
server.
<BR><BR>FIG. 2 illustrates an example of a system 200 in which the RFID edge server 202 includes an application server 204 running an RFID edge server application 206.  The RFID edge server application 206 can be written in a language such as Java.  In
one embodiment, the RFID edge server application 206 is written in Java, and the application server 204 is J2EE compliant.
<BR><BR>The RFID edge server 202 can have a TCP/IP socket for each of the RFID readers, or each active RFID readers.  One way of connecting the RFID edge server 202 with the RFID readers 208, 210 and 212 is to have a dedicated thread for monitoring each
socket.  In one embodiment, the number of RFID readers, n, can be quite large.  It is feasible for large warehouses to have over a hundred RFID readers.  For this reason, the RFID edge server 202 can be input/output (I/O) constrained.  Each of the access
threads needs to access a CPU and other Operating System Resources which require a certain amount of setup for each access thread.  The switching between a large number of threads can limit the number of RFID readers that can be associated with an RFID
edge server.
<BR><BR>As shown in FIG. 2, in one embodiment, the RFID edge server 202 is associated with multiple RFID readers 208, 210 and 212.  RFID edge server 202 can include an application server 204 to run applications, such as the RFID edge server application
206.  The RFID edge server 202 can have TPC/IP socket connections 216, 218 and 220 with multiple RFID readers 208, 210 and 212.  The RFID edge server 202 can have fewer access threads 214 for the RFID readers than there are socket connections.
<BR><BR>Each data access thread can be used to service multiple sockets.  In one embodiment, at least some of the access threads 214 are written in a non-Java language.  For example, the access thread 214 can be written in code that is native to the
machine.
<BR><BR>The operating system for the machine running the application server 204 can be such that it will provide TPC/IP socket information to access thread 214 which can then be provided to the application server 204 for use by the RFID edge server
application 206.  Alternately, the operation for the machine can allow the application server 204 to obtain the low level control of the TPC/IP sockets using the access thread 214.
<BR><BR>In one embodiment, the RFID readers 208, 210 and 214 are connected to the RFID edge server 202 through the local network 222.  The TPC/IP protocol can be used for interconnecting between the RFID edge server 202 and RFID readers 208, 210 and 212.
<BR><BR>In one embodiment, the system can use sockets which are serviced by multiplexed reader/accessor threads.  Muxer sockets can support asynchronous network I/O for the upper protocol layers via a completion based contract.  In one embodiment,
Protocol layers can implement MuxableSocket as a completion callback and register it with the muxers (via SocketMuxer.register).  It can then issue asynchronous read requests to the muxers (via SocketMuxer.read).  Under the covers, muxers can perform the
network input operations either asynchronously (for OS which supports asynchronous IO, e.g. I/O completion port on Win2K), or in a non-blocking fashion (for OS which supports non-blocking I/O, e.g. select/poll on Unix platforms, or the JDK 1.4
non-blocking I/O API, which is modeled closely after the select API), or synchronously with polling.  To avoid undue copying, data can be read into protocol layers' buffer directly).  When the read operation is completed, the muxer can notify the
protocol layer via the completion callback (MuxableSocket.dispatch).  In the event of any network errors or end of file or timeout reached for the socket, the muxer can notify the protocol layer via an error handler
(MuxableSocket.hasException/endOfStream).
<BR><BR>In one embodiment the number of access threads used is fixed.  The number of or, default number of, access threads can be proportional to the number of CPUs of the machine running the RFID edge server.  In one exemplary embodiment, there are two
access threads per CPU to access the sockets of the RFID readers.
<BR><BR>FIG. 3 illustrates a RFID edge server 302 used to associate with multiple RFID readers 304, 306 and 308 at a location.  The RFID edge server 302 can include an application server 310 which can be adapted to filter communications from the readers
304, 306 and 308 and to boxcar event reports 312 to a central server 314.
<BR><BR>In one embodiment, the RFID edge server 302 can have a RFID edge server application running 316 which can include message filtering 318 and boxcar code 320.  In one embodiment, messages are received by the RFID edge server.  The RFID edge server
application 316 can filter away duplicate or otherwise unnecessary reports.  In one embodiment, the reports can be boxcarred, that is multiple event reports can be combined together into a single message from the RFID edge server 302 to the central
server 314.  This can reduce the amount of traffic between the RFID edge server 302 and the central server 314, and thus increase the number of RFID edge servers that can interact with the central server 314.  The boxcarred reports can include data from
messages provided by the RFID readers 304, 306 and 308.  The central server 314 can unboxcar the messages.  A boxcarring protocol at the RFID edge servers and at the central servers that ensures the correct boxcarring and unboxcarring of the messages.
<BR><BR>One embodiment of the present invention is a method wherein at the RFID edge server 302, messages are received from RFID readers 304, 306 and 308.  The messages are filtered at the RFID edge server 302.  Event reports can be boxcarred, which can
include the data from the messages and sent to the central server 314.
<BR><BR>A computer readable media including code adapted to do the above method can also be used.  This code can be part of the RFID edge server application 316 running on the application server 312 of the RFID edge server 302.
<BR><BR>An RFID edge server 402 can be associated with multiple RFID readers 404, 406 and 408.  The RFID edge server 402 can include an application server 410 adapted to receive an RFID software package as an archive file 412.  The application server 410
can open an archive file 412 to install the RFID software 414 into the application server 410.  In one embodiment, the archive file is a J2EE standard archive file, such as a JAR file (Java Archive).
<BR><BR>The Java.TM.  Archive (JAR) file format can enable the bundling of multiple files into a single archive file.  Typically, a JAR file will contain the class files and auxiliary resources associated with applets and applications.  The JAR file
format can provide many benefits: Security: The contents of a JAR file can be signed.  Users who recognize your signature can then optionally grant your software security privileges it wouldn't otherwise have.  Decreased download time: If an applet is
bundled in a JAR file, the applet's class files and associated resources can be downloaded to a browser in a single HTTP transaction without the need for opening a new connection for each file.  Compression: The JAR format allows you to compress your
files for efficient storage.  Packaging for extensions: The extensions framework provides a means by which you can add functionality to the Java core platform, and the JAR file format defines the packaging for extensions.  Package Sealing: Packages
stored in JAR files can be optionally sealed so that the package can enforce version consistency.  Sealing a package within a JAR file means that all classes defined in that package must be found in the same JAR file.  Package Versioning: A JAR file can
hold data about the files it contains, such as vendor and version information.  Portability: The mechanism for handling JAR files is a standard part of the Java platform's core API.
<BR><BR>The RFID edge server application archive 412 can be provided from a website which can be downloaded into the application server 410 of the RFID edge server 402.  The archive file can include large number of other files, such as classes and
binaries needed to run an RFID edge server application.  The RFID edge server archive 412 can make it easier to obtain and maintain the RFID software 414.
<BR><BR>One embodiment of the present invention is a method wherein at the RFID edge server 402, RFID software packaged in an archive file 412 is received.  At the RFID edge server 402, the archive file can be opened to install the RFID software 414 into
the application server 410.  A computer readable medium implementing this method can also be used.
<BR><BR>FIG. 5 illustrates an example in which EPCIS server 502 includes an application server 504 set up to receive an EPCIS software package as an archive file 506 and to open archive file to install the EPCIS software 508 into the application server
504.  The EPCIS archive file can be a standard archive file such as a JAR file.  The use of an EPCIS server application archive 506 can make it easier to obtain and maintain the EPCIS software 508.
<BR><BR>On embodiment of the present invention is a method including at an EPCIS server 502, receiving EPCIS software packaged into an archive file 506, and opening the archive file 506 to install the EPCIS software 508 into the application server 504. 
Additionally, the present invention can comprise a computer readable medium including code adapted to do the steps of the method.
<BR><BR>FIG. 6 illustrates an example of an RFID edge server 602 is associated with a multiple RFID readers 604, 606 and 608.  The RFID edge server 602 can include an application server 610 adapted to do store-and-forward messaging to a central server
612.  A store-and-forward messaging unit can maintain copies of messages sent to the central server 216 until conformation of the messages is received from the central server 612
<BR><BR>Additionally, store and forward messaging can operate in as part of a transaction in which case the message is stored after forwarding until any transaction including the message completes.  In one embodiment, the transactional messaging uses a
two-phase commit, such as with XA messaging, to ensure that either all updates are done or all the updates are rolled back.
<BR><BR>In one embodiment, store and forward messaging is implemented using a JMS server 614.  In one embodiment, the JMS server operates in a transactional manner and transactions involving the messages can be rolledback.
<BR><BR>The Java Message Service is a Java API that allows applications to create, send, receive, and read messages.  The JMS API defines a common set of interfaces and associated semantics that allow programs written in the Java programming language to
communicate with other messaging implementations.
<BR><BR>The JMS API enables communication that is not only loosely coupled but also Asynchronous.  A JMS provider can deliver messages to a client as they arrive; a client does not have to request messages in order to receive them.  Reliable.  The JMS
API can ensure that a message is delivered once and only once.  Lower levels of reliability are available for applications that can afford to miss messages or to receive duplicate messages.
<BR><BR>In one embodiment, a message, such as message A, is sent to the central server 216 and the RFID edge server 602 maintains a copy of message A until an acknowledgment from the central server 216, or a determination that a transaction including the
Message A is completed.
<BR><BR>In one embodiment of the present invention a method wherein a RFID edge server 602 receives data from multiple RFID readers 604, 606 and 608.  At the RFID reader 602, store and forwarding of messages including at least some of the data is done to
the central server 612.  A computer readable medium implementing such a method can be used.
<BR><BR>FIG. 7 illustrates an RFID edge server application server 702 associate with multiple RFID readers 704, 706 and 708.  The RFID edge server 702 can include an application server which is adapted to use JMX administration 712, or some other J2EE
standards-based administration.
<BR><BR>The JMX administration 712 can be used to manage resources related to the RFID edge server.  Java Management Extensions (JMX) can use managed beans, or MBeans.  An MBean is a managed Java object, similar to a JavaBean.TM., that follows the design
patterns set forth in the instrumentation level of the JMX specification.  An MBean can represent a device, an application, or any resource that needs to be managed.  MBeans expose a management interface: a set of readable and/or writable attributes and
a set of invokable operations, along with a self-description.  The management interface does not change throughout the life of an MBean instance.  MBeans can also emit notifications when certain defined events occur.
<BR><BR>The JMX administration 712 can use MBeans to set configuration for the RFID edge server.  An administration server at the RFID edge server 702 can be used to set the configuration of the RFID edge server.  The administration server can be run on
the application server.  An administration console can be used to manage the RFID edge server 702.  The administration console can include a graphical interface for determining and setting the state and configuration of the RFID edge server.
<BR><BR>The RFID edge server of claim 1, wherein the JMX administration can be used to manage the connections with the multiple RFID readers.  The JMX administration can be used to manage the RFID edge server remotely.
<BR><BR>FIG. 8 shows one embodiment of the present invention which an RFID edge server 802 is used to associate with multiple RFID readers 804, 806 and 808.  RFID edge server 802 includes an application server 810 using a Java connector 812.  The Java
connector can be used to communicate with ERP software 814.
<BR><BR>The J2EE Connector (Java connector) architecture defines a standard architecture for connecting the J2EE platform to heterogeneous (Enterprise Information Systems) EIS systems.  Examples of EIS systems include ERP, mainframe transaction
processing, database systems, and legacy applications not written in the Java programming language.  The J2EE Connector (Java connector) architecture defines a set of scalable, secure, and transactional mechanisms to enable the integration of EISs with
application servers and enterprise applications.
<BR><BR>The J2EE Connector architecture enables an EIS vendor to provide a standard resource adapter for its EIS.  The resource adapter plugs into an application server, providing connectivity between the EIS, the application server, and the enterprise
application.  An EIS vendor needs to provide just one standard resource adapter which has the capability to plug in to any application server that supports the J2EE Connector architecture.
<BR><BR>Multiple resource adapters (that is, one resource adapter per type of EIS) are pluggable into an application server.  This capability enables application components deployed on the application server to access the underlying EIS systems.
<BR><BR>The Java connector 812 can connect to ERP software at another location.  RFID edge server also communicates with an EPCIS server.
<BR><BR>Device management functions of the RFID edge server can include Health Monitoring & Diagnostics, Fault Management, Tag Activity Monitoring, Performance Analysis, Analytics to determine underperforming components, Maintenance & Upgrades, Version
Control, Firmware & Software upgrades, Provisioning & Configuration, and Web based configuration.
<BR><BR>FIG. 9 shows an exemplary system of one embodiment.  An application server at a distribution center can run application(s) including an ALE definition interface, A device management GUI and workflows to convert ALE events to EPCIS specific events
that can be published to an EPCIS repository.  A data center can include integration software to integrate with ERP software and provide data to web sites which can use a portal product.
<BR><BR>FIG. 12 illustrates the use of reader connectivity software that can be run at an application server at an RFID edge server.  A number of different reader protocols can be supported which can allow a single RFID edge server interact with multiple
different types of RFID readers.
<BR><BR>The use of the systems of the present invention can have a number of advantages.
<BR><BR>1) Scalability--RFID systems can have hundreds of RFID readers each reading data hundreds of times a second.  This can cause CPU utilization, network bandwidth, and/or data repository constraints.  A number of features can help this problem
including: Thread Multiplexing, "Non-blocking" IO, Eliminating duplicates through ALE, "Boxcarring" packets and Handling data storage at the Enterprise Application Integration (EAI) layer.
<BR><BR>2) Availability--Availability of the system can be improved by reducing dependency on the database at the edge and ensuring availability of integration/server layer.  In one embodiment, a file system and not a database is used at the RFID edge
server.  A database can be used at an integration layer, such as at a central server.  Load balancers can be used as well as high-availability messaging through clustered JMS servers.  A clustered database can be used to back" the integration/server
layer.
<BR><BR>3) Security--Administration should be secure to prevent readers from being turned off and items being stolen.  The administrative interface can be protected by authentication, authorization, audit, and potentially over SSL (Secure Socket Layer). 
This SSL "handshake" can be very CPU intensive.  Alternately, the entire stack (reader/edge/server) can be wrapped in a firewall to enable perimeter authorization.  The RFID system security can be plugable to 3.sup.rd party security providers.
<BR><BR>4) Interoperability--Interoperability can include interoperability with packaged applications and with readers, Support for standards-based JCA Adapters.  Reader abstraction layer at the edge that readily facilitates device drivers additions and
updates.
<BR><BR>5) Integration Layer--The Global view is difficult to support due to different readers and "edge-server" formats.  Complex event composition is costly and not suitable at CPU intensive edge (transformation and duplicate elimination).  The RFID
edge-server need not be designed to integrate with other components of an integrated software platform.  A unifying EAI layer can be used to compose and correlate events from different sets of RFID infrastructure.  Clustered integration servers can be
used to absorb the load of complex event composition.  The EAI product can be fully integrated with Business Process Management (BPM) and Portal.
<BR><BR>6) Administration--Different administration consoles from different components can prevent a centralized administration.  RFID components can integrate with existing management vendors (HP Openview, Tivoli) and can support protocols like SNMP &
JMX.
<BR><BR>7) Messaging--Once RFID becomes mission critical there can be a need to ensure messages are sent once and only once.  The JMX embodiment can support "exactly once" semantics.  Transaction can guarantee on message enqueue & dequeue.  The RFID edge
server can provide asynchronous JMS support.
<BR><BR>FIG. 13 shows an RFID edge server 1302.  The RFID edge server 1302 can include an Application server 1304.  The application server 1304 can run an RFID edge server application 1306.  The application server 1304 can include, or have associated,
with it a security framedwork 1308 that can control the security for the RFID edge server application 1306.  The security framework 1308 can ensure that the RFID edge server is not tampered with using rules and entitlements.  This can prevent the RFID
readers 1310, 1312, and 1314 from being turned off or the RFID data erased which could facilitate stealing from a warehouse, for example.  The security framework 108 can also ensure that an audit is not modified by any user.
<BR><BR>The security framework 1308 can also provide an API for connecting to security plugins 1316, 1318, and 1320 that can allow third party security to operate using the known features and user interface.  The security plugin can be code internal to
the RFID edge server 1302 or can be code external to the RFID edge server 1302.  The security framework 1308 translates the security selections from a security plugin to security for the RFID edge server application 1306.  The security framework 1308
(and thus any of the security plugins 1316, 1318, and 1320) can have default settings for the RFID edge server application 1306.
<BR><BR>The Security Framework can provide end-to-end application security, covering J2EE and non-J2EE components of an application hosted on an application server.
<BR><BR>In one embodiment: 1.  Security policies can be created and managed by Security Administrators.  2.  Security policies can be flexible, dynamic, powerful rules that can be changed without recoding and redeployment.
<BR><BR>Integration with existing security solutions is greatly simplified.  The Security Framework can separate application business logic from the security code.  Security services, including security business rules, can be provided by the
infrastructure and don't have to be coded in the application.  A user interface for security administration can be provided out-of-the-box.
<BR><BR>A built-in dynamic security rules engine can makes it easy to implement dynamic business rules for security policies, and does not require any downtime to update these rules.  It can allow mapping company business rules to security policies in
distributed deployments, providing easy customization of application security to business requirements.
<BR><BR>With an API, such as an open Security Service Provider Interface (SSPI), the framework can allow third party security solutions on the market to plug in and provide their security services to applications running on the application server, and
also enables adding custom extensions.
<BR><BR>Single Sign-On can be automatically available to applications on the application server without any additional programming.
<BR><BR>The Security Framework can provide interfaces to other products, J2EE containers, and customer applications, and delegates requests to the appropriate security plug-in. Default security plug-ins can perform the following functions out-of-the-box:
<BR><BR>Authentication: Can authenticate, verify, and map security tokens to an internal format for security support.  Can support delegated username/password and certificate authentication with the application server, and HTTP certificate authentication
via the standard service provided in a Web server.
<BR><BR>Authorization: Can enforce authorization policies for resources, taking business policies into consideration.  Can support role-based authorization, in which access is based on job function and business rules.
<BR><BR>Auditing: Can Audit all security actions in support of non-repudiation.  Provides a customizable set of data for auditing security events such as failed login attempts, authentication requests, rejected digital certificates, and invalid roles.
<BR><BR>Public key infrastructure: Can support standard public key <B><I>encryption</I></B> for data or digital signatures, or when electronic authentication of a client's identity is required.
<BR><BR>Credential mapping: Can map a user's authentication credentials to those required for legacy applications, so that the legacy application gets the necessary credential information.
<BR><BR>Role mapping: Can map roles to users or groups, based on policy.  Can determine the appropriate set of roles granted to an application server user or group for a resource.
<BR><BR>The security plug-in scheme can be based on a set of Security Service Provider Interfaces (SPIs) for the plug-in points.  The Security SPIs can be used by customers or third-party vendors to develop security plug-ins for the WebLogic Server
environment.  Security SPIs can be available for authentication, authorization, auditing, credential mapping, role mapping, and the public key infrastructure (supporting the Java standard Key Store for encrypted storage of public and private <B><I>encryption</I></B>
keys).
<BR><BR>An open, interface-based security architecture allows use of existing security products while taking advantage of new security technologies available in the marketplace.  With this architecture, a security installation can support security
vendors' full value propositions, not just a subset.  A user's choice of security products can be "mixed and matched" to create complete custom security solutions.  In fact, the application server can run more than one security plug-in for a given
function, and users can set constraints that govern which product or protocol will be used in a given situation.
<BR><BR>As users integrate new solutions or modify existing ones, administrators can set security policy for each security plug-in, using a built-in menu-driven policy tool.  Security policy can govern authorization: the rules and constraints for
accessing resources or assuming roles.  More than one security plug-in can run concurrently, as part of a migration or transition scheme, and set security policy accordingly.  An Adjudicator function can resolve any conflicts in interpretation when
making authorization decisions.
<BR><BR>The security framework can support any choice of vendors and protocols because it separates the details of the security system from application code, simplifying application maintenance and management.  Changing security system components or
policies need not entail modifying applications.  This unified architecture makes it easy to integrate best-of-breed security solutions, and to replace components of a security system with the latest technologies from third-party vendors, or from a
development staff.  The ability to swap in new security plug-ins and technologies as needed reduces the total cost of ownership and maximizes the return on investment in security technologies.
<BR><BR>The security framework can organize users into users and groups that take on roles according to defined security policies.  Users can be organized into groups.  Groups can be used to represent organizational boundaries as well as to simplify
administration.  Each application user and group is mapped to a role dynamically during application execution, when authorization is needed.
<BR><BR>Roles and policies can determine access to system resources, and permitted behaviors.  User roles can be registered by an administrator using the built-in menu-driven security policy tool embedded in the BEA-supplied Authorization plug-in. The
security policy tool's interface can reflects business concepts, not programming concepts, and allows an administrator to create simple prose-based rules for dynamically assigning roles and calculating access privileges.  Application developers are freed
from having to write application code to implement complex business policies, because the policy tool separates the tasks of business policy creation and application creation.
<BR><BR>The roles that a user can be assigned to are determined by policies defined by the administrator, on behalf of the company.  Since policies reflect business security rules, a company's management can set security policies rather than the software
development staff.  Security policies can easily be changed with changes in business conditions.
<BR><BR>The role-and-policy-based security scheme can replaces the previous scheme of users, groups, and access control lists (ACLs), and can offers clear advantages for ease of administration and ease of adaptability as security requirements change. 
Using roles and policies for authorization permits dynamic computation of access status for each resource, for each user or group.
<BR><BR>FIG. 14 shows an RFID edge server 1402.  The RFID edge server 1402 includes an application server 1404 that can run on RFID edge sever application 1406.  The application server 1404 can include a web service reliability messaging (WSRM) unit 1408
that can includes a Reliable Messaging Processors (RMPs) 1410.  The WSRM can send messages in a reliable manner between the RFID edge server 1402 and the central server 1412.  The central server 1412 can have its own WSRM unit 1414 with its own RMP 1416. WSRM uses Simple Object Access Protocol (SOAP) messages 1418 and pass through the normally configured firewalls 1420 and 1422 because they use HTTP.  The SOAP messages can contain the RFID data from the RFID edge server 1402.
<BR><BR>WSRM can be used to send messages in a service oriented architecture (SOA) system, such as an SOA system using a service bus and service registry.
<BR><BR>In one embodiment, the RFID edge server outbound notifications are transmitted using Web Service Reliable Messaging (WSRM).  WSRM is an open specification for ensuring reliable message delivery for Web services.  WSRM can send messages using the
Simple Object Access Protocol (SOAP).  SOAP is a simple XML-based protocol to let applications exchange information over HTTP.  HTTP messages are often allowed through firewalls, so WSRM can allow reliable messaging in a format that can pass through most
firewalls In one embodiment, WSRM utilizes a transactional messaging system in the implementation.
<BR><BR>Reliability, can include the ability to guarantee message delivery to "users" with a chosen level of protocol capability and Quality of Service (QOS).  Again, the users can be either other WS protocols (e.g. WS Security, WS Distributed
Management, WS-Notifications, etc), or Application layer/user information messages which are exchanged between the end points of the connection.
<BR><BR>To facilitate WS Reliability, SOAP based Reliable Messaging Processors (RMPs), in the sender and in the receiver endpoints can be used.  For example both the RFID edge server and the central sever can have RMPs.  The RMPs can work together to
ensure that messages are delivered in a reliable manner over a connection that may be inherently unreliable.  The sender and receiver RMPs can operate on newly defined SOAP headers that are transmitted as either self contained messages, or they can be
attached to other WS protocol messages or user data messages (all of which are SOAP/XML encoded).  Fault messages may extend to the SOAP message body.
<BR><BR>The "users" can determine the level of WS Reliability.  Reliability may include one or more reliable messaging protocol capability for the delivery of WS messages Guaranteed delivery to the user or Application entity (the message is persisted
(i.e. stored in non-volatile memory) in the sender RMP until delivery to the ultimate receiver has been acknowledged.  Either a message is delivered, or the sending application is notified of a delivery failure.  A resending mechanism controlled by
acknowledgements and handled by RMPs, can overcome occasional connection failures or message loss.  Duplicate elimination--Delivery at most once--with duplicates detected and eliminated by the RMP receiver.  Duplicate messages could be generated
accidentally by some network component (e.g. a router), or intentionally by a resending mechanism.  In both cases, it is critical for applications that require only a single instance of the message be delivered, independent of how much time elapsed
between the reception of a message and its duplicate.  Guaranteed message ordering--when delivered by the RMP receiver to the user, the messages can be properly sequenced, in the same order as they were sent.  The problem arises when messages are
received out of sequence or were resent when acknowledgements are lost.  The RMP reorders the messages before delivery to the application, waiting for delayed messages to arrive.  (Solution: RMP transmitter retransmits unacknowledged messages--after a
time-out--and the RMP receiver re-orders received out of sequence messages so that they are properly delivered to the user/Application entity)
<BR><BR>The users of the WS Reliability protocol may agree upon any or all of the above message delivery capabilities.  Different users or applications may choose different protocol capabilities, which are conveyed to the RMP sender and receiver prior to
initiating communications.  Alternatively, the receiver RMP can determine the protocol capability via explicit parameter values sent in each reliable message request.
<BR><BR>For purposes of the WSRM TC, QOS can be defined as the ability to determine at least some of the following aspects:
<BR><BR>Message persistence (ability to store a message until it is reliably delivered to the Application).
<BR><BR>Message acknowledgement (by the receiver and resending (by sender on No Ack time-out).
<BR><BR>Ordered delivery of messages (by use of Sequence numbers).
<BR><BR>Delivery status awareness for both sender and receiver (via state saving and status check-pointing).
<BR><BR>The WSRM specification can define extensions to SOAP Headers.  It is assumed that the payload (user information) is specified using a WSDL description (fault messages may also use the payload to convey fault code information).
<BR><BR>In the Reliable Messaging Model, the sender node can send a message to the receiver node (i.e., intermediaries are assumed to be transparent in the WS Reliability specification).  Upon receipt of the message and at the appropriate time, the
receiver node sends back an Acknowledgment message or Fault message to the sender node.
<BR><BR>There are three ways for the receiver to send back an Acknowledgment message or a Fault message to the sender.  These are referred to as the "RM Reply patterns," which are defined as follows: Response RM-Reply Pattern A Response RM-Reply pattern
can be in use if the outbound Reliable Message is sent in the underlying protocol request, and the resultant Acknowledgment message (or Fault message) is contained in the underlying protocol response message which corresponds to the original request.  In
essence, the Acknowledgement is "piggybacked" onto the business response message.  Callback RM-Reply Pattern A Callback RM-Reply pattern can be in use if the Acknowledgment message (or Fault message) is contained in an underlying protocol request of a
second request/response exchange (or a second one-way message), operating in the opposite direction to the message containing the outbound Reliable Message.  Polling RM-Reply Pattern The Polling RM-Reply pattern can be used if a second underlying
protocol request is generated, in the same direction as the one containing the outbound Reliable Message, to act as a "request for acknowledgment." The Acknowledgment message (or Fault message) is contained in the underlying protocol response to this
request.  This polling pattern can be used in instances where it is inappropriate for the sender of reliable messages to receive underlying protocol requests e.g. the sender behind a firewall.
<BR><BR>These three reply patterns provide "the users" with flexibility to send reliable request/response or one-way SOAP messages (Callback and Polling patterns).  Callback is important for one-way request message patterns and for batching of
acknowledgements and fault messages.
<BR><BR>Additionally, "polling" enables reliable message delivery to extend beyond the firewall, which might otherwise block external reliable messages from reaching the intended recipient.  Polling makes it possible to use the WS Reliability protocol,
even when a firewall prevents 3rd parties from initiating messages or requests.
<BR><BR>WS Reliability Protocol Capabilities:
<BR><BR>Three types of message delivery capabilities are defined in the WS Reliability protocol.  One or more of these protocol capabilities may be used with each of the RM Reply patterns.  The selection is dependent on prior end user agreements or
explicitly inferred by the receiver RMP from request messages.
<BR><BR>Guaranteed Delivery
<BR><BR>This is to successfully deliver a message from a sender RMP to a receiver RMP without failure; if this is not possible, to report the failure to the sender's application.  To realize guaranteed delivery, the message is persisted (i.e. stored) in
the sender RMP until delivery to the receiver is acknowledged, or until the ultimate failure is reported to it's requester.  (There is a requirement on the underlying transport protocol that the message MUST be transported without corruption.) If message
persistence is lost for any reason, it is no longer possible to guarantee message delivery.  Since the reliability of message persistence is a property of the system implementation, the conditions under which guaranteed message delivery holds is also a
property of the system implementation.
<BR><BR>Duplicate Elimination
<BR><BR>A number of conditions may result in transmission of duplicate message(s), e.g. temporary downtime of the sender or receiver, a routing problem between the sender and receiver, etc. In order to provide at-most-once semantics, the ultimate RMP
receiver can eliminate duplicate messages and never present them to the user.  Messages with the same Message Identifier value can be treated as duplicates and not delivered to the application.
<BR><BR>Guaranteed Message Ordering
<BR><BR>Some applications will expect to receive a sequence of messages from the same sender in the same order those messages were sent.  Although there are often means to enforce this at the Application layer, this is not always possible or practical. 
In such cases, the Reliable Messaging layer is required to guarantee the message order.  WRSM defines a model to meet this requirement.
<BR><BR>When the sender application sends three messages (1), (2), and (3) with Guaranteed Message Ordering, the receiver's RMP can guarantee that message order when it makes those messages available to the receiver's application (the user).  When a
receiver's RMP receives messages (1) and (3), the receiver's RMP can make message (1) available to the application, but it persists message (3) until message (2) is received.  When receiver's RMP receives message (2), it can then makes message (2) and
(3) available to the application, in that order.
<BR><BR>One embodiment may be implemented using a conventional general purpose or a specialized digital computer or microprocessor(s) programmed according to the teachings of the present disclosure, as will be apparent to those skilled in the computer
art.  Appropriate software coding can readily be prepared by skilled programmers based on the teachings of the present disclosure, as will be apparent to those skilled in the software art.  The invention may also be implemented by the preparation of
integrated circuits or by interconnecting an appropriate network of conventional component circuits, as will be readily apparent to those skilled in the art.
<BR><BR>One embodiment includes a computer program product which is a storage medium (media) having instructions stored thereon/in which can be used to program a computer to perform any of the features presented herein.  The storage medium can include,
but is not limited to, any type of disk including floppy disks, optical discs, DVD, CD-ROMs, micro drive, and magneto-optical disks, ROMs, Rams, EPROM's, EPROM's, Drams, Rams, flash memory devices, magnetic or optical cards, Nano systems (including
molecular memory ICs), or any type of media or device suitable for storing instructions and/or data.
<BR><BR>Stored on any one of the computer readable medium (media), the present invention includes software for controlling both the hardware of the general purpose/specialized computer or microprocessor, and for enabling the computer or microprocessor to
interact with a human user or other mechanism utilizing the results of the present invention.  Such software may include, but is not limited to, device drivers, operating systems, execution environments/containers, and user applications.
<BR><BR>The foregoing description of preferred embodiments of the present invention has been provided for the purposes of illustration and description.  It is not intended to be exhaustive or to limit the invention to the precise forms disclosed.  Many
modifications and variations will be apparent to one of ordinary skill in the relevant arts.  For example, steps performed in the embodiments of the invention disclosed can be performed in alternate orders, certain steps can be omitted, and additional
steps can be added.  The embodiments were chosen and described in order to best explain the principles of the invention and its practical application, thereby enabling others skilled in the art to understand the invention for various embodiments and with
various modifications that are suited to the particular use contemplated.  It is intended that the scope of the invention be defined by the claims and their equivalents.
<BR><BR><CENTER><B>* * * * *</B></CENTER>
<HR>
<CENTER>
<a href=http://patimg2.uspto.gov/.piw?Docid=07394377&homeurl=http%3A%2F%2Fpatft.uspto.gov%2Fnetacgi%2Fnph-Parser%3FSect1%3DPTO2%2526Sect2%3DHITOFF%2526u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.htm%2526r%3D140%2526f%3DG%2526l%3D50%2526d%3DPTXT%2526s1%3D((RFID%252BOR%252B%252522radio%252Bfrequency%252Bidentification%252522).ABTX.%252BAND%252B(((Cryptography%252BOR%252BCrypto)%252BOR%252BEncryption)%252BOR%252BCipher))%2526p%3D3%2526OS%3Dabst%2F(RFID%252Bor%252B(%252522radio%252Bfrequency%252Bidentification%252522))%252BAND%252B(Cryptography%252Bor%252BCrypto%252Bor%252BEncryption%252Bor%252BCipher)%2526RS%3D(ABST%2F(RFID%252BOR%252B%252522radio%252Bfrequency%252Bidentification%252522)%252BAND%252B(((Cryptography%252BOR%252BCrypto)%252BOR%252BEncryption)%252BOR%252BCipher))&PageNum=&Rtype=&SectionNum=&idkey=NONE&Input=View+first+page><img src="/netaicon/PTO/image.gif" alt="[Image]" border="0" valign="middle"></A>
<table>
<tr><td align=center><A HREF="http://ebiz1.uspto.gov/vision-service/ShoppingCart_P/ShowShoppingCart?backUrl1=http%3A//patft1.uspto.gov/netacgi/nph-Parser?Sect1%3DPTO2%26Sect2%3DHITOFF%26u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.htm%26r%3D140%26f%3DG%26l%3D50%26d%3DPTXT%26s1%3D((RFID%252BOR%252B%252522radio%252Bfrequency%252Bidentification%252522).ABTX.%252BAND%252B(((Cryptography%252BOR%252BCrypto)%252BOR%252BEncryption)%252BOR%252BCipher))%26p%3D3%26OS%3Dabst%2F(RFID%252Bor%252B(%252522radio%252Bfrequency%252Bidentification%252522))%252BAND%252B(Cryptography%252Bor%252BCrypto%252Bor%252BEncryption%252Bor%252BCipher)&backLabel1=Back%20to%20Document%3A%207394377"><img border=0 src="/netaicon/PTO/cart.gif" border=
0 valign=middle alt="[View Shopping Cart]"></A>
<A HREF="http://ebiz1.uspto.gov/vision-service/ShoppingCart_P/AddToShoppingCart?docNumber=7394377&backUrl1=http%3A//patft1.uspto.gov/netacgi/nph-Parser?Sect1%3DPTO2%26Sect2%3DHITOFF%26u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.htm%26r%3D140%26f%3DG%26l%3D50%26d%3DPTXT%26s1%3D((RFID%252BOR%252B%252522radio%252Bfrequency%252Bidentification%252522).ABTX.%252BAND%252B(((Cryptography%252BOR%252BCrypto)%252BOR%252BEncryption)%252BOR%252BCipher))%26p%3D3%26OS%3Dabst%2F(RFID%252Bor%252B(%252522radio%252Bfrequency%252Bidentification%252522))%252BAND%252B(Cryptography%252Bor%252BCrypto%252Bor%252BEncryption%252Bor%252BCipher)&backLabel1=Back%20to%20Document%3A%207394377">
<img border=0 src="/netaicon/PTO/order.gif" valign=middle alt="[Add to Shopping Cart]"></A>
</td></tr>
<tr><td align=center>
<A  HREF=/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=140&f=S&l=50&d=PTXT&s1=((RFID+OR+%22radio+frequency+identification%22).ABTX.+AND+(((Cryptography+OR+Crypto)+OR+Encryption)+OR+Cipher))&p=2&Query=abst/(RFID+or+(&quot;radio+frequency+identification&quot;))+AND+(Cryptography+or+Crypto+or+Encryption+or+Cipher)><IMG VALIGN=MIDDLE SRC=/netaicon/PTO/prevlist.gif border=0 ALT=[PREV_LIST]></A>
<A  HREF=/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=140&f=S&l=50&d=PTXT&s1=((RFID+OR+%22radio+frequency+identification%22).ABTX.+AND+(((Cryptography+OR+Crypto)+OR+Encryption)+OR+Cipher))&p=3&Query=abst/(RFID+or+(&quot;radio+frequency+identification&quot;))+AND+(Cryptography+or+Crypto+or+Encryption+or+Cipher)><IMG VALIGN=MIDDLE SRC=/netaicon/PTO/hitlist.gif border=0 ALT=[HIT_LIST]></A>
<A  HREF=/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=140&f=S&l=50&d=PTXT&s1=((RFID+OR+%22radio+frequency+identification%22).ABTX.+AND+(((Cryptography+OR+Crypto)+OR+Encryption)+OR+Cipher))&p=4&Query=abst/(RFID+or+(&quot;radio+frequency+identification&quot;))+AND+(Cryptography+or+Crypto+or+Encryption+or+Cipher)><IMG VALIGN=MIDDLE SRC=/netaicon/PTO/nextlist.gif border=0 ALT=[NEXT_LIST]></A>
<A  HREF=/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=139&f=G&l=50&d=PTXT&s1=((RFID+OR+%22radio+frequency+identification%22).ABTX.+AND+(((Cryptography+OR+Crypto)+OR+Encryption)+OR+Cipher))&p=3&OS=abst/(RFID+or+(&quot;radio+frequency+identification&quot;))+AND+(Cryptography+or+Crypto+or+Encryption+or+Cipher)><IMG VALIGN=MIDDLE SRC=/netaicon/PTO/prevdoc.gif border=0 ALT=[PREV_DOC]></A>
<A  HREF=/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=141&f=G&l=50&d=PTXT&s1=((RFID+OR+%22radio+frequency+identification%22).ABTX.+AND+(((Cryptography+OR+Crypto)+OR+Encryption)+OR+Cipher))&p=3&OS=abst/(RFID+or+(&quot;radio+frequency+identification&quot;))+AND+(Cryptography+or+Crypto+or+Encryption+or+Cipher)><IMG VALIGN=MIDDLE SRC=/netaicon/PTO/nextdoc.gif border=0 ALT=[NEXT_DOC]></A>

<a href="#top"><img valign=middle src="/netaicon/PTO/top.gif" border=0 alt="[Top]"></a>
</td></tr>
</table>
<a name="bottom"></a>
<a href="http://www.uspto.gov/patft/index.html"><img src="/netaicon/PTO/home.gif" alt="[Home]" border="0" valign=middle></a>
<a href="/netahtml/PTO/search-bool.html"><img src="/netaicon/PTO/boolean.gif" alt="[Boolean Search]" border="0" valign=middle></a>
<A HREF="/netahtml/PTO/search-adv.htm"><IMG BORDER="0" SRC="/netaicon/PTO/manual.gif" ALT="[Manual Search]" valign=middle></A>
<a href="/netahtml/PTO/srchnum.htm"><img src="/netaicon/PTO/number.gif" alt="[Number Search]" border="0" valign=middle></a>
<A HREF="http://www.uspto.gov/patft/help/help.htm"><IMG BORDER="0" SRC="/netaicon/PTO/help.gif" ALT="[Help]" valign=middle></A>
</center>
</BODY>
</HTML>